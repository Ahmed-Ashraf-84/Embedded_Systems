/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stm32f103c6_TIMER_driver.h"
#include "stm32f103c6_GPIO_driver.h"
#include "stm32f103c6_EXTI_driver.h"
#include "stm32f103c6_I2C_driver.h"
#include "stm32f103c6_ADC_driver.h"
#include "CortexM3/CortexM3_Core_NVIC.h"
//#include "ECU_Layer.h"//extern
void delay(unsigned int time);
void delay2(void);

void(*ISR)(void);


//TIM_Handle_t tim2 ;


ADC_Handle_t adc ;
ADC_Init_t okm ;

injected_t ing;
regular_t uu;

Analog_watchdog_t awd;

sampling_t sam;

int main(void)
{
	/* LAB1 with driver
	 *


	//enable clock gpio A and B
	CLK_GPIOA_EN  												//RCC_APB2ENR |= (1<<2);
	CLK_GPIOB_EN												//RCC_APB2ENR |= (1<<3);
	// PB1 -> output open-drain
	GPIO_PIN_config_t pinconfig;								//GPIOB_CRL &= 0XFFFFFF0F;
		pinconfig.GPIO_PIN_Number =	PIN1;						//GPIOB_CRL |= (1<<4);
		pinconfig.GPIO_MODE = MODE_OUTPUT_OD;					//GPIOB_CRL |= (1<<6);
		pinconfig.GPIO_OUTPUT_SPEED = OUTPUT_SPEED_10 ;

		GPIO_init(GPIOB, &pinconfig);


	// PB13 -> output open-drain
		pinconfig.GPIO_PIN_Number =	PIN13;						//GPIOB_CRH &= 0XFF0FFFFF;
		pinconfig.GPIO_MODE = MODE_OUTPUT_OD;					//GPIOB_CRH |= (1<<20);
		pinconfig.GPIO_OUTPUT_SPEED = OUTPUT_SPEED_10 ;			//GPIOB_CRH |= (1<<22);

		GPIO_init(GPIOB, &pinconfig);
		// PA1 -> input floating
		pinconfig.GPIO_PIN_Number =	PIN1;						//GPIOA_CRL &= 0XFFFFFF0F;
		pinconfig.GPIO_MODE = MODE_INPUT_FLO;					//GPIOA_CRL |= (1<<6);

		GPIO_init(GPIOA, &pinconfig);
		// PA13 -> input floating
		pinconfig.GPIO_PIN_Number =	PIN13;						//GPIOB_CRH &= 0XFF0FFFFF;
		pinconfig.GPIO_MODE = MODE_INPUT_FLO;					//GPIOB_CRH |= (1<<22);

		GPIO_init(GPIOA, &pinconfig);

	while(1)
	{
		if(GPIO_Read_Pin(GPIOA, PIN1)==0)
		{
			GPIO_Toggle_Pin(GPIOB, PIN1);						//GPIOB_ODR ^= (1<<1) ;

			while(GPIO_Read_Pin(GPIOA, PIN1)==0);
		}
		if(GPIO_Read_Pin(GPIOA, PIN13)==1)
		{
			GPIO_Toggle_Pin(GPIOB, PIN13);						//GPIOB_ODR ^= (1<<13) ;

		}

		delay(5);



	}

*/

	//EXTI_config_t try ;

	//try.PORT_PIN=EXTIA_PIN0;

	/*I2C_config_t I2C_config ;
	I2C_config.ACK_enable = ACK_ENABLED ;
	I2C_config.General_call_ADD = General_call_ENABLED ;
	I2C_config.I2C_SM_FM = SM ;
	I2C_config.I2C_mode = Master ;
	I2C_config.I2Cx = I2C1 ;
	I2C_config.Peripheral_mode = I2C_mode ;
	I2C_config.SCLK_FREQ = 80 ;
	//I2C_config.Slave_config = General_call_ENABLED ;
	I2C_config.stretch_mode = stretch_ENABLED ;



	I2C_init(&I2C_config);

*/
//		timer
/**/
/*	ISR = delay2 ;

	TIM_Base_Init_t ink;

	tim2.ISR_Handler = ISR ;
	tim2.TIM_mode = TIM_mode ;
	tim2.handler = interrupt ;
	tim2.Init  = &ink;
	tim2.Init->CounterMode = upcounter ;
	tim2.Init->Period = 4 ;
	tim2.Init->Prescaler = 4000 ;		// .5 u	T	===>
	tim2.Instance  = TIM2 ;
*/
/*
	TIM_PWM_Init_t PWM;
	PWM.Mode = PWM_1 ;
	PWM.polarity = Active_HIGH ;
	PWM.preload = Preload_register_enabled ;
	PWM.selection = Edge_aligned_mode ;
	PWM.PWM_value = 3 ;
*/
	//RCC->CFGR |= 5 << 11 ;

	//TIM_PWM_init(&tim2, &PWM);
	//TIM_init(&tim2);

/*
	adc.Instance = ADC1 ;
	adc.Init = &okm ;
	adc.Init->regular_config = &uu ;
	adc.Init->injected_config = &ing ;
	adc.Init->AWD_config = &awd ;
	adc.Init->sample_time_config = &sam ;
	adc.Init->regular_config->NbrOfConversion = conversions_1 ;

	adc.Init->regular_config->conversions_1_th = channel_1 ;
*/
	/*
	 *  adc.Init->regular_config->conversions_2_th = channel_2 ;
		adc.Init->regular_config->conversions_3_th = channel_5 ;
		adc.Init->regular_config->conversions_4_th = channel_9 ;
	 */
/*
	adc.Init->ClockPrescaler = divided_2;
	adc.Init->Continuous_Mode = cont_disabled;
	adc.Init->Scan_Mode = SCAN_disabled;
	adc.Init->alignment = Right_Alignment;
	adc.Init->interrupt_enable = disabled;
	adc.Init->sample_time_config->NbrOfchannel_SAMP = 1;
	adc.Init->sample_time_config->channel_1 = cycles_7_and_half;

	uint16_t Data = 6;
	//TIM_init(&tim2);
	ADC_Init(&adc);

	ADC_Start_Conv(&adc);

	Data = ADC_Get_Conv_Result(&adc);
*/
	// NVIC->ISER[0] |= (1<<5);
}

void delay2(void)
{
	ADC1->CR2.CAL = enabled ;

}

void delay(unsigned int time)
{
	unsigned int i=0, j=0;

	for(i=0;i<time;i++)
		for(j=0;j<255;j++);

}

