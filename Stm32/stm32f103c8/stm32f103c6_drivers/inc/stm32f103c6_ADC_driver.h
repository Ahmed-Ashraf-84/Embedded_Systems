/*
 * stm32f103c6_ADC_driver.h
 *
 *  Created on: Nov 30, 2023
 *      Author: Ahmed Ashraf
 */

#ifndef INC_STM32F103C6_ADC_DRIVER_H_
#define INC_STM32F103C6_ADC_DRIVER_H_

//-----------------------------
//Includes
//-----------------------------

#include "stm32f103c6_LQFP48.h"
//#include "stm32f103c6_GPIO_driver.h"
#include "stm32f103c6_RCC_driver.h"


//-----------------------------
//Macros Configuration References
//-----------------------------

/*
 *  VREF+		Input, analog reference positive		The higher/positive reference voltage for the ADC,
														2.4 V ≤ VREF+ ≤ VDDA

    VDDA		Input, analog supply 					Analog power supply equal to VDD and
														2.4 V ≤VDDA ≤3.6 V

    VREF-		Input, analog reference negative		The lower/negative reference voltage for the ADC,
														VREF- = VSSA

	VSSA 		Input, analog supply 					ground Ground for analog power supply equal to VSS

	******VDDA and VSSA have to be connected to VDD and VSS, respectively.*******

 * */

//@ref Enable_Definition
enum Enable_Definition
{
	enabled 		= 0b1 ,
	disabled 		= 0b0

};

//@ref scan_Enable_Definition  ******** SCAN -> CR1
enum SCAN_Enable_Definition
{
	SCAN_enabled 		= 0b1 ,
	SCAN_disabled 		= 0b0

};

//@ref cont_Enable_Definition  ******** CONT -> CR2
enum CONT_Enable_Definition
{
	cont_enabled 		= 0b1 ,
	cont_disabled 		= 0b0    //single mode

};

//@ref ALIGN_Enable_Definition  ******** ALIGN -> CR2
enum ALIGN_Enable_Definition
{
	Left_Alignment 		= 0b1 ,
	Right_Alignment 	= 0b0

};


//@ref CLK_PSC_Definition  ******** ADCPRE -> RCC_CFGR
enum CLK_PSC_Definition
{
	divided_2 		= 0 ,
	divided_4 			,
	divided_6 		    ,
	divided_8

};

//@ref sampling_time_Definition  ******** SMPx[2:0] -> SMPR1
enum Samp_time_Definition
{
	  cycles_1_and_half		= 0 ,
	  cycles_7_and_half			,
	  cycles_13_and_half		,
	  cycles_28_and_half		,
	  cycles_41_and_half		,
	  cycles_55_and_half		,
	  cycles_71_and_half		,
	  cycles_239_and_half
};

//@ref regular channel sequence length_Definition  ******** L[3:0] -> SQR1
enum R_conv_Len_Definition
{
	  conversions_1		= 0 ,
	  conversions_2			,
	  conversions_3			,
	  conversions_4			,
	  conversions_5			,
	  conversions_6			,
	  conversions_7			,
	  conversions_8			,
	  conversions_9			,
	  conversions_10		,
	  conversions_11		,
	  conversions_12		,
	  conversions_13		,
	  conversions_14		,
	  conversions_15		,
	  conversions_16
};

//@ref  injected channel sequence length_Definition  ******** L[3:0] -> SQR1
enum IN_conv_Len_Definition
{
	  conversion_1		= 0 ,
	  conversion_2			,
	  conversion_3			,
	  conversion_4
};

//@ref Regularchannel_num_Definition  ********
enum channel_num_Definition
{
	  channel_0		= 0 ,
	  channel_1			,
	  channel_2			,
	  channel_3			,
	  channel_4			,
	  channel_5			,
	  channel_6			,
	  channel_7			,
	  channel_8			,
	  channel_9
};

//@ref Analog watchdog channel selection_Definition  ******** SQx[2:0] -> SQRx
enum AWD_Channel_selection_Definition
{
	None						= 0 	,
	All_injected_channels				,
	All_regular_channels				,
	All_regular_injected_channels 		,
	Single_injected_channel		= 5		,
	Single_regular_channel				,
	Single_regular_OR_injected_channel


};

//@ref regular_Event_Trigger_Definition  ******** EXTSEL[2:0] -> CR2
/*
 * The selection of the external trigger EXTI line11 or TIM8_TRGO event for regular channels is done through
	configuration bits ADC1_ETRGREG_REMAP and ADC2_ETRGREG_REMAP for ADC1 and ADC2,
	respectively.

	*******		return to AFIO to config the 4 bits which control the event to trigger    **********
	*******		The software source trigger events can be generated by setting a bit in a register
				(SWSTART and JSWSTART in ADC_CR2).
 * */
enum Regular_Event_Trigger_Definition
{
	 Timer_1_CC1	= 0		,
	 Timer_1_CC2			,
	 Timer_1_CC3			,
	 Timer_2_CC2			,
	 Timer_3_TRGO			,
	 Timer_4_CC4			,
	 EXTI_line_11			,
	 RE_software_trigger

};


//@ref injected_Event_Trigger_Definition  ******** EXTSEL[2:0] -> CR2
/*
 * The selection of the external trigger EXTI line11 or TIM8_TRGO event for regular channels is done through
	configuration bits ADC1_ETRGREG_REMAP and ADC2_ETRGREG_REMAP for ADC1 and ADC2,
	respectively.

	*******		return to AFIO to config the 4 bits which control the event to trigger    **********
	*******		The software source trigger events can be generated by setting a bit in a register
				(SWSTART and JSWSTART in ADC_CR2).
 * */
enum injected_Event_Trigger_Definition
{
	TIM1_TRGO	= 0		,
	TIM1_CC4			,
	TIM2_TRGO			,
	TIM2_CC1			,
	TIM3_CC4			,
	TIM4_TRGO			,
	EXTI_line_15		,
	IN_software_trigger

};

//@ref Regular External trigger event Enable_Definition
enum Regular_trigger_Enable_Definition
{
	Regular_enabled 		= 0b1	 ,
	Regular_disabled 		= 0b0

};


//@ref injected External trigger event Enable_Definition
enum injected_trigger_Enable_Definition
{
	injected_enabled 		= 0b1 	 ,
	injected_disabled 		= 0b0

};


//-----------------------------
//User type definitions (structures)
//-----------------------------
typedef struct
{
	enum R_conv_Len_Definition NbrOfConversion :4 ; /*Specifies the number of input that will be
													converted*/
	enum channel_num_Definition  conversions_1_th		:4;/*Specifies which channel to be converted first*/
	enum channel_num_Definition  conversions_2_th		:4;
	enum channel_num_Definition conversions_3_th		:4;
	enum channel_num_Definition conversions_4_th		:4;
	enum channel_num_Definition conversions_5_th		:4;
	enum channel_num_Definition conversions_6_th		:4;
	enum channel_num_Definition conversions_7_th		:4;
	enum channel_num_Definition conversions_8_th		:4;
	enum channel_num_Definition conversions_9_th		:4;
	enum channel_num_Definition  conversions_10_th		:4;
	enum channel_num_Definition conversions_11_th		:4;
	enum channel_num_Definition  conversions_12_th		:4;
	enum channel_num_Definition conversions_13_th		:4;
	enum channel_num_Definition conversions_14_th		:4;
	enum channel_num_Definition conversions_15_th		:4;
	enum channel_num_Definition conversions_16_th		:4;


}regular_t;


typedef struct
{
	enum IN_conv_Len_Definition NbrOfConversion :2 ; 			/*Specifies the number of input that will be
															converted*/
	enum channel_num_Definition  conversions_1_th		:4;/*Specifies which channel to be converted first*/
	enum channel_num_Definition  conversions_2_th		:4;
	enum channel_num_Definition conversions_3_th		:4;
	enum channel_num_Definition conversions_4_th		:4;

} injected_t;

typedef struct
{
	uint32_t high_threshold :12;
	uint32_t low_threshold 	:12;
	//uint32_t AWD_channel 	:5;
	enum AWD_Channel_selection_Definition AWD_channel:3;
	enum Enable_Definition AWD_IRQ:1;
	void(*AWD_ptr)(void);

}Analog_watchdog_t;

typedef struct
{
	enum channel_num_Definition NbrOfchannel_SAMP :4 ;

	enum Samp_time_Definition channel_0		:3;
	enum Samp_time_Definition channel_1		:3;
	enum Samp_time_Definition channel_2		:3;
	enum Samp_time_Definition channel_3		:3;
	enum Samp_time_Definition channel_4		:3;
	enum Samp_time_Definition channel_5		:3;
	enum Samp_time_Definition channel_6		:3;
	enum Samp_time_Definition channel_7		:3;
	enum Samp_time_Definition channel_8		:3;
	enum Samp_time_Definition channel_9		:3;


}sampling_t;

typedef struct
{
	enum Regular_Event_Trigger_Definition regular_event      :3;
	enum injected_Event_Trigger_Definition injected_event    :3;
	enum Regular_trigger_Enable_Definition regular_trigger	 :1;
	enum injected_trigger_Enable_Definition injected_trigger :1;

}External_trigger_t;



typedef struct
{
	enum CLK_PSC_Definition ClockPrescaler : 2; /* Selects the ADC clock frequency */
	//uint32_t Resolution; /* Configures the ADC resolution mode */
	enum SCAN_Enable_Definition Scan_Mode 		 :1; /* The scan sequence direction. */
	enum CONT_Enable_Definition Continuous_Mode  :1; /* Specifies whether the conversion is performed
	in Continuous or Single mode */
	enum ALIGN_Enable_Definition alignment; /* Specifies whether the ADC data alignment
	is left or right */
	injected_t * injected_config;
	regular_t *  regular_config;
	sampling_t * sample_time_config;
	Analog_watchdog_t *AWD_config;
	External_trigger_t *Ex_trigger_config;
	uint16_t injected_channel_offset	:12;   /* converted data value is decreased by the offset */
	void(*EOC_IRQ)(void);
	enum Enable_Definition interrupt_enable :1;
	//uint32_t NbrOfDiscConversion; /* Specifies the number of discontinuous
	/*conversions in
	which the main sequence of regular group */
	//uint32_t DiscontinuousConvMode; /* Specifies whether the conversion sequence of
	/*regular
	group is performed in Complete-sequence/Discontinuous
	sequence */
	//uint32_t ExternalTrigConv; /* Select the external event used to trigger the
	//start
	//of conversion */
	//uint32_t ExternalTrigConvEdge; /* Select the external trigger edge and enable
	//it */
	//uint32_t DMAContinuousRequests; /* Specifies whether the DMA requests are
	//performed in
	//one shot or in continuous mode */
	//uint32_t EOCSelection; /* Specifies what EOC (End Of Conversion) flag is used
	//for conversion polling and interruption */


}ADC_Init_t;



typedef struct {
ADC_t *Instance; /* Pointer to ADC descriptor */
ADC_Init_t *Init; /* ADC initialization parameters */
//uint32_t NbrOfCurrentConversionRank; /* ADC number of current conversion
//rank */
//DMA_HandleTypeDef *DMA_Handle; /* Pointer to the DMA Handler */
//HAL_LockTypeDef Lock; /* ADC locking object */
//__IO uint32_t State; /* ADC communication state */
//__IO uint32_t ErrorCode; /* Error code */
} ADC_Handle_t;

/*
* ===============================================
* APIs Supported by "MCAL TIMER DRIVER"
* ===============================================
*/

void ADC_Init(ADC_Handle_t *ADCx);
void ADC_DEinit(ADC_Handle_t *ADCx);
void ADC_SelectChannel(ADC_Handle_t *ADCx);
void ADC_Start_Conv(ADC_Handle_t *ADCx);
uint16_t ADC_Get_Conv_Result(ADC_Handle_t *ADCx);


/*
 *
 *
 * \Calibrating an Analog-to-Digital Converter (ADC) in an STM32 microcontroller involves compensating for variations or inaccuracies in the ADC's measurements. For the STM32F103C6 microcontroller, calibration typically involves adjusting the ADC to improve accuracy in converting analog signals to digital data.

The STM32F103C6 microcontroller's ADC calibration process typically involves the following steps:

Calibration Initialization: First, you initialize the ADC and its calibration settings. This involves configuring registers such as ADC_CR2 and ADC_CR1.

Calibration Procedure: The calibration procedure in the STM32 microcontrollers involves a series of steps. Here's a simplified version:

Single-Ended Calibration: This calibration mode calibrates individual ADC channels. It involves applying a known voltage to the ADC input and comparing the digital output against the expected value.

Offset Calibration: This corrects for any offset errors in the ADC. The offset error is the difference between the actual value and the expected value when the input is zero.

Gain Calibration: This compensates for any gain errors in the ADC. The gain error is the difference between the actual slope of the ADC's transfer function and the ideal slope.

Calculating Calibration Factors: After the calibration procedure, the ADC calibration factors (offset and gain correction values) are calculated. These values are used to adjust subsequent ADC measurements to improve accuracy.

Regarding a time diagram, it would typically involve a series of steps showing the ADC's behavior during calibration, including voltage application, sampling, conversion, and calibration factor determination. Unfortunately, I can't generate visual diagrams directly here, but you might find diagrams illustrating ADC calibration procedures in the STM32F103C6 reference manual or in application notes provided by STMicroelectronics.

For more detailed and precise information, I'd recommend referring to the STM32F103C6 reference manual or specific datasheets provided by STMicroelectronics, as they contain detailed information, diagrams, and procedures related to ADC calibration for this particular microcontroller.
 *
 *
 *
 *
 *
 *
 *
 *
 * */




#endif /* INC_STM32F103C6_ADC_DRIVER_H_ */
